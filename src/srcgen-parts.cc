// srcgen-parts.cc
//
// Copyright 2011 Martin Read. All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the author nor the names of any other contributors
//    may be used to endorse or promote products derived from this software
//    without their specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.

#include <string.h>
#include <stdio.h>
#include <string>
#include <ctype.h>
#include <errno.h>
#include <libmormegil/srcgen-parts.hh>

std::string *libmormegil::tagify(const char *__restrict__ name, const char *__restrict__ prefix)
{
    int i;
    int len = strlen(name);
    std::string *foo = new std::string(prefix);
    for (i = 0; i < len; ++i)
    {
        if (isalpha(name[i]))
        {
            (*foo) += toupper(name[i]);
        }
        else if (isdigit(name[i]))
        {
            (*foo) += name[i];
        }
        else
        {
            (*foo) += '_';
        }
    }
    return foo;
}

enum Edge
{
    North_edge, East_edge, South_edge, West_edge
};

// This next function is used to generate a sequential lookup table for radial effects.
void libmormegil::emit_chebyshev_spiral(FILE *srcfile, FILE *hdrfile, unsigned int radius,
                                       const char *__restrict__ macrotag, const char *__restrict__ nmsp)
{
    fputs("/* This file is automatically generated. DO NOT EDIT! */\n\n", srcfile);
    fputs("/* This file is automatically generated. DO NOT EDIT! */\n\n", hdrfile);
    fprintf(srcfile, "#define %s_cc\n", macrotag);
    fprintf(hdrfile, "#ifndef inc_%s_hh\n#define inc_%s_hh\n#include <libmormegil/Coord.hh>\n", macrotag, macrotag);
    if (nmsp && *nmsp)
    {
        fprintf(srcfile, "libmormegil::Offset %s::cheby_spiral[%d * %d] = \n{\n", nmsp,
                (radius * 2 + 1), (radius * 2 + 1));
        fprintf(hdrfile, "namespace %s\n{\n    ", nmsp);
    }
    else
    {
        fprintf(srcfile, "libmormegil::Offset cheby_spiral[%d * %d] = \n{\n", nmsp,
                (radius * 2 + 1), (radius * 2 + 1));
    }
    fprintf(hdrfile, "extern libmormegil::Offset cheby_spiral[%d * %d];\n",
            (radius * 2 + 1), (radius * 2 + 1));
    int i;
    int cur_radius = 0;
    int cur_y = 0;
    int cur_x = 0;
    Edge cur_edge = North_edge;
    for (i = 0; i < ((radius * 2 + 1) * (radius * 2 + 1)); ++i)
    {
        fprintf(srcfile, "{ %d, %d },\n", cur_y, cur_x);
        switch (cur_edge)
        {
        case North_edge:
            if (!cur_radius)
            {
                --cur_y;
                ++cur_radius;
            }
            else if (cur_x == cur_radius)
            {
                cur_edge = East_edge;
                ++cur_y;
            }
            else
            {
                ++cur_x;
                if (cur_x == 0)
                {
                    ++cur_radius;
                    --cur_y;
                }
            }
            break;
        case East_edge:
            if (cur_y == cur_radius)
            {
                cur_edge = South_edge;
                --cur_x;
            }
            else
            {
                ++cur_y;
            }
            break;
        case South_edge:
            if (cur_x == -cur_radius)
            {
                cur_edge = West_edge;
                --cur_y;
            }
            else
            {
                --cur_x;
            }
            break;
        case West_edge:
            if (cur_y == -cur_radius)
            {
                cur_edge = North_edge;
                ++cur_x;
                if (cur_x == 0)
                {
                    ++cur_radius;
                    --cur_y;
                }
            }
            else
            {
                --cur_y;
            }
            break;
        }
    }
    fprintf(srcfile, "};\n");
    if (nmsp && *nmsp)
    {
        fprintf(hdrfile, "}\n");
    }
    fprintf(hdrfile, "#endif\n");
}

// vim:ts=8:sw=4:expandtab:fo=croq
